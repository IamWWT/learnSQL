--------------------------------关系模型---------------------------------
关系database 是建立在 关系模型【本质上是很多个存储数据的二维表】 上的。

----表-----
每一行：记录（record)，记录一个逻辑意义上的数据。
每一列：字段（column)，同一个表的每一行记录都拥有若干个字段。

----字段-----
定义了 数据类型，以及，是否允许为NULL。【NULL表示字段数据不存在，并不是0或者''等类似】
$ 通常情况，字段应该避免允许为NULL，这样可以简化查询条件，加快查询进度，利于应用程序读取数据和无需判断是否为NULL。

-----关系database的表 VS. Excel表---------------
关系database的 表和表之间 需要建立“一对多”，“多对一”，“一对一”的关系，这样才能按照应用程序的逻辑来组织和存储数据。
举例：一个班级表【一行一个班级，一个班级多个学生】和一个学生表的关系就是“一对多”。
      反过来，
      先在学生表定位一行记录，如ID=1的小明，的班级ID假如是201，找到班级表ID=201的记录，即二年级一班，此时，学生表和班级表是“多对一”的关系。
      再建一个教师表，里面只存老师的ID，一个班级总是对应一个老师，班级表和教师表是“一对一”关系。


----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
关系database中，关系通过 主键和外键 来维护。
----------------------------主键-----------------------------
同一个表的所有记录(record)都有相同的字段（column)定义。

【关系表】的一个重要约束：任意两条记录不能重复。
NOTE: ·不能重复·不是指的 两条records不完全相同，而是指，通过·某个字段·【唯一区分】出不同的记录，这个<字段>被称为【主键】。

对【主键】的关键要求：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改主键会造成系列影响。

【选取主键】的基本原则： 不适用任何业务相关的字段作为主键。一般把<这个字段>命名为id。

常见可作为【id字段的类型】：
--1. 自增 整数类型。[database]会在插入data时[自动]为每一条record分配一个自增整数。这样，不用担心-主键重复，和，不用自己-预先生成主键。【BIGINT NOT NULL AUTO_INCREMENT类型】
--2. 全局唯一GUID类型：一种字符串。GUID算法通过网卡MAC低脂、时间戳、随机数，[保证]任意PC在任意time生成的字符串是不同的，大部分编程语言都内置了GUID算法，可自己预先预算出主键。
！！！INT自增类型时，一张表记录超过2147483647（约21亿）时，会达到上限出错。用BIGINT自增类型最多可达约922亿亿条records。

------------------------------联合主键--------------------------
关系database，还允许通过·多个字段唯一标识`record，即，大于2个的字段都可设为主键，称【联合主键】

【联合主键】：允许一列由重复，只要不是所有主键列都重复即可。

NOTE: 没必要时，尽量不使用，联合主键给关系表带来了【复杂度】的上升。


-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-------------------------------外键----------------------------
----------------一对多------------------------
如：一个班级 可 对应 多个学生。
外键，通过外加的字段列，将两个表中的数据关联起来。
举例：students表 和 classes表。
	通过students表，找到id=1的小明，查找他属于which class。
	此时，为表达这种一对多的关系，需要在students表中插入一列class_id，让它的值与classes表中的某条record相对应。这样就可以，通过class_id直接定位出一个students表的record对应到classes的哪条record。

# 外键并不是通过列名实现的，而实通过定义外键约束实现的。
ALTER TABLE students
ADD CONSTRINT fk_class_id	# 外键约束的名称 fk_clss_id
FOREIGN KEY (class_id)		# 制定了将这个外键关联到 classes表的id列（即class表的主键）
REFERENCES class (id);

通过定义外键约束，关系数据库可以保证`无法插入`无效的data，即，若classes表不存在id=99的记录，students表就无法插入class_id==99的记录。

！！外键约束会降低数据库的性能，大部分互联网应用程序为追求速度，并不设置外键约束，而仅靠应用程序自身来保证逻辑的正确性，此时，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。

# 删除一个外键约束：
ALTER TABLE students
DROP FOREIGN KEY fk_class_id; 
# NOTE：删除外键约束并没有删除外键这一列，删除列通过DROP COLUMN ... 实现。

------------------多对多--------------------
如，一个老师可以对应多个班级，一个班级也可以对应多个老师。班级表和老师表之间存在多对多关系。

多对多关系，通过 两个一对多关系 实现，即，通过一个·中间表·，关联两个一对多关系，就形成了多对多关系。


******直观例子************

teachers表：
id			name
1			Zhang
2			Wang
3			Li
4			Zhao

classes表：
id			name
1			class-1
2			class-2

中间表teacher_class关联两个一对多关系：
id		teacher_id		class_id
1		1			1
2		1			2
3		2			1
4		2			2
5		3			1
6		4			4

由中间表可知，teachers到classes的关系 和 classes到teachers的关系，即“多对多”关系。


-------------------一对一-----------------------
一对一关系：一个表的记录对应到另一个表的唯一记录。

如：students表的每个学生都有自己的联系方式。把联系方式存入另一个表，就得到“一对一”关系。
疑问：为什么不直接在students表中增加一个mobile列？
答：  业务允许的话，可以。但是有时，如果某个学生没有手机号，contacts表就不存在对应记录。实际上，一对一关系，【准确来说】，是contacts表一对一对应students表。
      一些应用 会把一个大表 拆分成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高性能。如，用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只要查询user_info表，不需要查询user_profiles表，这样就提高了查询速度。



-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
------------------索引-------------------
【目的】：为了从上万上亿条记录中[非常快速地查找]速度。

【索引定义】：是关系database中对某一列ORd多个列的value进行预排序的【数据结构】。
	-目的，database system不必扫描整个表，只需-直接定位-到符合条件的记录，大大加快查询速度。

【例子】：studnets表中查询scroe。
--对score列创建索引
ALTER TABLE students
ADD INDEX idx_score (score);	# 创建了一个名称为idx_score，使用score的索引。
# 索引名称=任意。
# 如果索引由多列，可在括号依次写上，如下。
ALTER TABLE students
ADD INDEX idx_score (name, score);

【索引效率】：取决于索引列的值是否散列，即，该列的value越不相同，那么索引效率越高。

【一张表多个索引】
#优点# 提高查询效率
#缺点# 插入、更新、删除record时，需要同时修改索引，从而，索引越多，这些操作就越慢。

【对于主键】，关系database会自动对其创建主键索引。使用主键索引的【效率是最高的】，因为主键会保证【绝对唯一】。

------唯一索引-------------
【唯一索引】：设计关系数据表时，看上去唯一的列，如身份证号、邮箱地址..，因为具有业务含义，不宜作为主键。但根据业务要求，又具有[唯一性约束]：即不能出现两条记录存储了同一个身份证号，此时，可以给该列添加一个[唯一索引]。

【例子】students表中的name不能重复
ALTER TABLE students
ADD UNIQUE INDEX uni_name (name);	# 通过UNIQUE关键字添加了一个唯一索引
# 也可只对某一列添加一个唯一约束，而不创建唯一索引。
ALTER TABLE students
ADD CONSTRAINT uni_name UNIQUE (name);	# 此时，name列，没有索引，但仍然具有[唯一性保证]。

最后---
无论是否创建索引，对user和应用程序，使用关系database不会有任何区别，这里的意思是，只有速度差异。
索引在使用数据库过程中可逐步优化。

